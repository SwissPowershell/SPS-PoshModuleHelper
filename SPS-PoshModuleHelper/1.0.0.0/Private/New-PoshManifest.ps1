enum PMHPSEditions {
    Desktop
    Core
}
enum PMHProcessArchitecture {
    None
    MSIL
    X86
    X64
    IA64
    Amd64
    Arm
}
Class PMHPSData {
    [String[]] ${Tags}
    [URI] ${LicenseUri}
    [URI] ${ProjectUri}
    [URI] ${IconUri}
    [String] ${ReleaseNotes}
    PMHPSData() {}
    PMHPSData([String[]] ${Tags},[URI] ${LicenseUri},[URI] ${ProjectUri},[URI] ${IconUri}, [String] ${ReleaseNotes}) {
        $This.Tags = $Tags
        $This.LicenseUri = $LicenseUri
        $This.ProjectUri = $ProjectUri
        $This.IconUri = $IconUri
        $This.ReleaseNotes = $ReleaseNotes
    }
    [String] ParamToString ([String] ${Name}) {
        $Value = $This.$Name
        If ($Null -like $Value) {
            $RetVal = ''
        }Else{
            If ($Value -is [String[]]) {
                if ($Value.Count -gt 0){
                    $RetVal = "$($Name) = $(($Value | ForEach-Object {"'$($_)'"}) -join ',')"
                }Else{
                    $RetVal = ''
                }
            }Elseif ($Value -is [URI]) {
                $RetVal = "$($Name) = $(($Value | Select-Object -ExpandProperty 'AbsoluteUri'))"
            }Else {
                $RetVal = "$($Name) = '$($Value)'"
            }
        }
        Return $RetVal
    }
    [String] ToString() {
#         $RetVal2 = "PSData = @{$(($This | Get-Member -MemberType Properties | ForEach-Object ($This.$_)) -join ',')}"        
#         $RetVal = @"
#         PSData = @{
#             $($This.ParamToString('Tags'))
#             $($This.ParamToString('LicenseUri'))
#             $($This.ParamToString('ProjectUri'))
#             $($This.ParamToString('IconUri'))
#             $($This.ParamToString('ReleaseNotes'))
#         }
# "@
        Return "{PSData}"
    }
}
Class PoshManifest {
    # [String] ${Path}
    [String] ${Name}
    [String] ${RootModule}
    [Version] ${ModuleVersion} = [Version]::New('1.0.0.0')
    [GUID] ${Guid} = "$([GUID]::NewGuid())"
    [String] ${Author} = "$($($Env:UserName.Substring(0,1)).ToUpper())$($Env:UserName.Substring(1))"
    [String] ${CompanyName} = "$($($Env:UserName.Substring(0,1)).ToUpper())$($Env:UserName.Substring(1))''s Company"
    [String] ${Copyright} = "(c) $(Get-Date -Format yyyy) $($($Env:UserName.Substring(0,1)).ToUpper())$($Env:UserName.Substring(1))''s Company"
    [String] ${Description}
    [Version] ${PowerShellVersion}
    [Version] ${PowerShellHostVersion}
    [String] ${PowerShellHostName}
    [Version] ${DotNetFrameworkVersion}
    [String] ${CLrVersion}
    [Nullable[PMHProcessArchitecture]] ${ProcessorArchitecture}
    [Object] ${RequiredModules}
    [String[]] ${RequiredAssemblies}
    [String[]] ${ScriptsToProcess}
    [String[]] ${TypeToProcess}
    [String[]] ${FormatToProcess}
    [Object[]] ${NestedModules}
    [String[]] ${FunctionsToExport}
    [String[]] ${CmdletsToExport}
    [String[]] ${VariablesToExport}
    [String[]] ${AliasesToExport}
    [String[]] ${DscRessourcesToExport}
    [Object[]] ${ModuleList}
    [String[]] ${FileList}
    [PMHPSData] ${PrivateData} = [PMHPSData]::New()
    [String] ${HelpInfoUri}
    [String] ${DefaultCommandPrefix}
    [Nullable[PMHPSEditions]] ${CompatiblePSEditions}
    PoshManifest () {}
    PoshManifest ([String] ${Name}) {
        $This.Name = $Name
        $This.RootModule = "$($Name).psm1"
    }
    [String] ToString() {
        $RetVal = @"
# Module manifest for module: '$($This.Name)'
# Generated with: SPS-PoshModuleHelper
# Generated by: $($This.Author)
# Generated on: $(Get-Date -Format 'dd.MM.yyyy')
#
@{
"@
        $AllProperties = @('RootModule','ModuleVersion','Guid','Author','CompanyName','Copyright','Description','PowerShellVersion','PowerShellHostVersion','PowerShellHostName','DotNetFrameworkVersion','CLrVersion','ProcessorArchitecture','RequiredModules','RequiredAssemblies','ScriptsToProcess','TypeToProcess','FormatToProcess','NestedModules','FunctionsToExport','CmdletsToExport','VariablesToExport','AliasesToExport','DscRessourcesToExport','ModuleList','FileList','PrivateData','HelpInfoUri','DefaultCommandPrefix','CompatiblePSEditions')
        ForEach ($Property in $AllProperties) {
            if ($Property -eq 'PrivateData') {
                $AllPrivateDataProperties = @('Tags','LicenseUri','ProjectUri','IconUri','ReleaseNotes')
                $PrivateDataStr = @"
    PrivateData = @{
        PSData = @{
"@
                ForEach($PrivateDataProperty in $AllPrivateDataProperties) {
                    if ($This.PrivateData.$PrivateDataProperty -Notlike $Null) {$PrivateDataStr = "$($PrivateDataStr)`r`n            $($PrivateDataProperty) = $(($This.PrivateData.$PrivateDataProperty | ForEach-Object {"'$_'"}) -join ',')"}    
                }
                $PrivateDataStr = "$($PrivateDataStr)`r`n        }`r`n    }"
                $RetVal = "$($RetVal)`r`n$($PrivateDataStr)"
            }Else{
                if ($This.$Property -Notlike $Null) {$RetVal = "$($RetVal)`r`n    $($Property) = $(($This.$Property | ForEach-Object {"'$_'"}) -join ',')"}
            }
        }
        $RetVal = "$($RetVal)`r`n}"
        Return $RetVal
    }
    [System.Management.Automation.PSModuleInfo] Save([String] ${FilePath}) {
        $Path = Split-Path -LiteralPath $FilePath
        if ($FilePath -notlike '*.psd1') {
            Throw 'Filename not allowed, file extension should be .psd1'
        }
        if ($(Test-Path -LiteralPath $Path) -ne $True) {
            Try {
                New-Item -Path $Path -ItemType Directory -Force -ErrorAction 'Stop'
            }Catch {
                Throw "Unable to create path $($Path): $($_.Exception.Message)"
            }
        }
        Try {
            Set-Content -Value $This.ToString() -Path $FilePath -Force -ErrorAction 'Stop'
        }Catch {
            Throw "Unable to create gfle $($FilePath): $($_.Exception.Message)"
        }
        Try {
            $TestManifest = Test-ModuleManifest -Path $FilePath -Verbose:$False -ErrorAction 'Stop'
            Return $TestManifest
        }Catch {
            Throw $_
        }
    }
    Hidden [void] ParseFromFile([String] ${FilePath}) {
        #To Do
        Try {
            $Manifest = Test-ModuleManifest -Path $FilePath -ErrorAction 'Stop' -Verbose:$False
        }
        Catch {
            Throw "Unable to parse manifest: $($_.Exception.Message)"
        }
        $AllProperties = $This | Get-Member -MemberType 'Property' | Select-Object -ExpandProperty 'Name' | Where-Object {$_ -Notin @('CompatiblePSEditions','Name')}
        ForEach ($Property in $AllProperties) {
            if ($Property -ne 'PrivateData') {
                if ($Manifest.$Property -notlike $null) {
                    $This.$Property = $Manifest.$Property
                }
            }Else{
                $This.PrivateData.Tags = $Manifest.Tags
                $This.PrivateData.LicenseUri = $Manifest.LicenseUri
                $This.PrivateData.ProjectUri = $Manifest.ProjectUri
                $This.PrivateData.IconUri = $Manifest.IconUri
                $This.PrivateData.ReleaseNotes = $Manifest.ReleaseNotes
            }
        }
        $This.Name = $This.RootModule.Replace('.psm1','')
    }
    Static [PoshManifest] Parse([String] ${FilePath}) {
        $ManifestObject = [PoshManifest]::new()
        $ManifestObject.ParseFromFile($FilePath)
        Return $ManifestObject
    }
}
Function New-PoshManifest {
    [CMDLetBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = $True)]
        [String] ${Name},
        [Parameter(Position = 1, Mandatory = $False)]
        [String] ${RootModule},
        [Parameter(Position = 2, Mandatory = $False)]
        [Version] ${ModuleVersion} = [Version]::New('1.0.0.0'),
        [Parameter(Position = 3, Mandatory = $False)]
        [GUID] ${Guid} = "$([GUID]::NewGuid())",
        [Parameter(Position = 4, Mandatory = $False)]
        [String] ${Author} = "$($($Env:UserName.Substring(0,1)).ToUpper())$($Env:UserName.Substring(1))",
        [Parameter(Position = 5, Mandatory = $False)]
        [String] ${CompanyName} = "$($($Env:UserName.Substring(0,1)).ToUpper())$($Env:UserName.Substring(1))''s Company",
        [Parameter(Position = 6, Mandatory = $False)]
        [String] ${Copyright} = "(c) $(Get-Date -Format yyyy) $($($Env:UserName.Substring(0,1)).ToUpper())$($Env:UserName.Substring(1))''s Company",
        [Parameter(Position = 7, Mandatory = $False)]
        [String] ${Description},
        [Parameter(Position = 8, Mandatory = $False)]
        [Version] ${PowerShellVersion},
        [Parameter(Position = 9, Mandatory = $False)]
        [Version] ${PowerShellHostVersion},
        [Parameter(Position = 10, Mandatory = $False)]
        [String] ${PowerShellHostName},
        [Parameter(Position = 11, Mandatory = $False)]
        [Version] ${DotNetFrameworkVersion},
        [Parameter(Position = 12, Mandatory = $False)]
        [String] ${CLrVersion},
        [Parameter(Position = 13, Mandatory = $False)]
        [Nullable[PMHProcessArchitecture]] ${ProcessorArchitecture},
        [Parameter(Position = 14, Mandatory = $False)]
        [Object] ${RequiredModules},
        [Parameter(Position = 15, Mandatory = $False)]
        [String[]] ${RequiredAssemblies},
        [Parameter(Position = 16, Mandatory = $False)]
        [String[]] ${ScriptsToProcess},
        [Parameter(Position = 17, Mandatory = $False)]
        [String[]] ${TypeToProcess},
        [Parameter(Position = 18, Mandatory = $False)]
        [String[]] ${FormatToProcess},
        [Parameter(Position = 19, Mandatory = $False)]
        [Object[]] ${NestedModules},
        [Parameter(Position = 20, Mandatory = $False)]
        [String[]] ${FunctionsToExport},
        [Parameter(Position = 21, Mandatory = $False)]
        [String[]] ${CmdletsToExport},
        [Parameter(Position = 22, Mandatory = $False)]
        [String[]] ${VariablesToExport},
        [Parameter(Position = 23, Mandatory = $False)]
        [String[]] ${AliasesToExport},
        [Parameter(Position = 24, Mandatory = $False)]
        [String[]] ${DscRessourcesToExport},
        [Parameter(Position = 25, Mandatory = $False)]
        [Object[]] ${ModuleList},
        [Parameter(Position = 26, Mandatory = $False)]
        [String[]] ${FileList},
        [Parameter(Position = 27, Mandatory = $False)]
        [PMHPSData] ${PrivateData} = [PMHPSData]::New(),
        [Parameter(Position = 28, Mandatory = $False)]
        [String] ${HelpInfoUri},
        [Parameter(Position = 29, Mandatory = $False)]
        [String] ${DefaultCommandPrefix},
        [Parameter(Position = 30, Mandatory = $False)]
        [Nullable[PMHPSEditions]] ${CompatiblePSEditions},
        [Parameter(Position = 31, Mandatory = $False)]
        [String[]] ${Tags},
        [Parameter(Position = 32, Mandatory = $False)]
        [URI] ${LicenseUri},
        [Parameter(Position = 33, Mandatory = $False)]
        [URI] ${ProjectUri},
        [Parameter(Position = 34, Mandatory = $False)]
        [URI] ${IconUri},
        [Parameter(Position = 35, Mandatory = $False)]
        [String] ${ReleaseNotes}

    )
    BEGIN {
        #region Function initialisation DO NOT REMOVE
        [String] ${FunctionName} = $MyInvocation.MyCommand
        [DateTime] ${FunctionEnterTime} = [DateTime]::Now
        Write-Verbose "Entering : $($FunctionName)"
        #endregion Function initialisation DO NOT REMOVE
    }
    PROCESS {
        #region Function Processing DO NOT REMOVE
        Write-Verbose "Processing : $($FunctionName)"
        #region Function Processing DO NOT REMOVE
        $Object = [PoshManifest]::New()
        $Object.Name = $Name
        $Object.RootModule = $RootModule
        $Object.ModuleVersion = $ModuleVersion
        $Object.Guid = $Guid
        $Object.Author = $Author
        $Object.CompanyName = $CompanyName
        $Object.Copyright = $Copyright
        $Object.Description = $Description
        $Object.PowerShellVersion = $PowerShellVersion
        $Object.PowerShellHostVersion = $PowerShellHostVersion
        $Object.PowerShellHostName = $PowerShellHostName
        $Object.DotNetFrameworkVersion = $DotNetFrameworkVersion
        $Object.CLrVersion = $CLrVersion
        $Object.ProcessorArchitecture = $ProcessorArchitecture
        $Object.RequiredModules = $RequiredModules
        $Object.RequiredAssemblies = $RequiredAssemblies
        $Object.ScriptsToProcess = $ScriptsToProcess
        $Object.TypeToProcess = $TypeToProcess
        $Object.FormatToProcess = $FormatToProcess
        $Object.NestedModules = $NestedModules
        $Object.FunctionsToExport = $FunctionsToExport
        $Object.CmdletsToExport = $CmdletsToExport
        $Object.VariablesToExport = $VariablesToExport
        $Object.AliasesToExport = $AliasesToExport
        $Object.DscRessourcesToExport = $DscRessourcesToExport
        $Object.ModuleList = $ModuleList
        $Object.FileList = $FileList
        $Object.PrivateData = $PrivateData
        $Object.HelpInfoUri = $HelpInfoUri
        $Object.DefaultCommandPrefix = $DefaultCommandPrefix
        $Object.CompatiblePSEditions = $CompatiblePSEditions

        $Object.PrivateData.Tags = $Tags
        $Object.PrivateData.IconUri = $IconUri
        $Object.PrivateData.LicenseUri = $LicenseUri
        $Object.PrivateData.ProjectUri = $ProjectUri
        $Object.PrivateData.ReleaseNotes = $ReleaseNotes
    }
    END {
        #region Function closing  DO NOT REMOVE
        $TimeSpent = New-TimeSpan -Start $FunctionEnterTime -Verbose:$False -ErrorAction SilentlyContinue
        [String] ${TimeSpentString} = ''
        Switch ($TimeSpent) {
            {$_.TotalDays -gt 1} {
                $TimeSpentString = "$($_.TotalDays) D."
                BREAK
            }
            {$_.TotalHours -gt 1} {
                $TimeSpentString = "$($_.TotalHours) h."
                BREAK
            }
            {$_.TotalMinutes -gt 1} {
                $TimeSpentString = "$($_.TotalMinutes) min."
                BREAK
            }
            {$_.TotalSeconds -gt 1} {
                $TimeSpentString = "$($_.TotalSeconds) s."
                BREAK
            }
            {$_.TotalMilliseconds -gt 1} {
                $TimeSpentString = "$($_.TotalMilliseconds) ms."
                BREAK
            }
            Default {
                $TimeSpentString = "$($_.Ticks) Ticks"
                BREAK
            }
        }
        Write-Verbose "Ending : $($FunctionName) - TimeSpent : $($TimeSpentString)"
        #endregion Function closing  DO NOT REMOVE
        Return $Object
    }
}

$Test = New-PoshManifest -Name 'HelloWorld'
BREAK
$Test = [PoshManifest]::New('HelloWorld')
$Test.FunctionsToExport = @("A","B","C")
$Test.ToString()
$TestManifestResult = $Test.Save('C:\Temp\Toto\tutu\tata\turlututu.psd1')
$TestManifestResult


# $NewManifest = [PoshManifest]::New()
# $NewManifest.ParseFromFile('C:\Temp\Toto\tutu\tata\turlututu.psd1')
# $NewManifest
$NewManifest = [PoshManifest]::Parse('C:\Temp\Toto\tutu\tata\turlututu.psd1')
$NewManifest